%One can find all matches over an input string by constructing the modified position automaton from a regular expression and then simulating the automaton's transitions over the input string.
%The algorithm presented in this section is designed to track the start and end positions of all matches, including overlapping ones, without relying on backtracking.


%We can enable overlapped matching by modifying the position automaton's construction using the algorithm described on  \ref{alg:nfaPosCount}.
%For instance, consider the following regular expression:
%\begin{gather*}
%	r = (ab+ba)^2
%\end{gather*}

%\begin{algorithm}[H]
%\caption{\textsc{nfaPosCount}($R$): Construct Special Position Automaton}
%\label{alg:nfaPosCount}
%\begin{small}
%\begin{algorithmic}[1]
%\Require Regular expression $R$
%\Ensure NFA $A$
%
%\State $A \gets$ new empty NFA
%\State $i \gets A.\text{addInitialState}()$
%\State $A.\text{addTransitionStar}(i, i)$ \Comment{Accept any symbol from $\Sigma$}
%
%\State $f_R \gets R.\text{marked}()$
%\State $\text{stack} \gets$ empty stack
%\State $\text{addedStates} \gets$ empty map
%
%\ForAll{$p \in First(f_R)$}
%    \State $q \gets A.\text{addState}(p)$
%    \State $\text{addedStates}[p] \gets q$
%    \State $\text{stack}.\text{push}((p, q))$
%    \State $A.\text{addTransition}(i, p, q)$
%\EndFor
%
%% \State $\text{FollowSets} \gets Follow(f_R)$
%
%\While{stack is not empty}
%    \State $(s, s_{\text{idx}}) \gets \text{stack}.\text{pop}()$
%    \ForAll{$t \in Follow(f_R, s)$}
%        \If{$t \in \text{addedStates}$}
%            \State $q \gets \text{addedStates}[t]$
%        \Else
%            \State $q \gets A.\text{addState}(t)$
%            \State $\text{addedStates}[t] \gets q$
%            \State $\text{stack}.\text{push}((t, q))$
%        \EndIf
%        \State $A.\text{addTransition}(s_{\text{idx}}, t, q)$
%    \EndFor
%\EndWhile
%
%\State $e \gets A.\text{addState}()$
%\State $A.\text{addTransitionStar}(e, e)$
%
%\ForAll{$p \in f_R.\text{Last}()$}
%    \If{$p \in \text{addedStates}$}
%        \State $A.\text{addFinal}(\text{addedStates}[p])$
%        \State $A.\text{addTransitionStar}(\text{addedStates}[p], e)$
%    \EndIf
%\EndFor
%
%\end{algorithmic}
%\end{small}
%\end{algorithm}

%\section{Automata-Based Matching}
%
%Given a regular expression $R$, one can construct an NFA $A$ such that $L(A) = L(R)$. Matching then reduces to verifying whether the automaton $A$ accepts the input string $s$. In DFA-based engines, each character of the input leads to a deterministic transition from one state to another, resulting in a guaranteed linear-time match. In contrast, NFA-based engines may involve branching paths due to nondeterminism and can require simulating multiple transitions concurrently.

% \section{Backtracking and Performance Implications}

% Many practical regular expression engines (such as those in Java, Perl, and Python) implement matching using \emph{backtracking}, which simulates an NFA by exploring all possible paths through the automaton recursively. While this allows support for rich and flexible patterns, it can introduce performance issues in certain cases. In particular, patterns with nested or ambiguous quantifiers may cause excessive backtracking, leading to exponential runtime in the worst case—a phenomenon known as \emph{regular expression denial of service} (ReDoS).
%\section {Matching with the Modified Position Automaton}

%\begin{algorithm}[H]
%\caption{\textsc{tableMatcher}$(A, s)$: Modified Position Automaton Multi-matcher}
%\label{alg:table-matcher}
%\begin{small}
%\begin{algorithmic}[1]
%\Require $A = (\Sigma, Q, \delta, I, F)$: NFA
%\Require $s$: input string
%\Ensure $M$: mapping from final states to lists of match positions
%
%\State $symbols \gets$ list with $\varepsilon$ prepended to $s$
%\State $currentRow \gets$ empty map from states to list of position pairs
%\State $finalMatches \gets$ empty map from states to list of matches
%\State $position \gets 0$
%
%\ForAll{$sym$ in $symbols$}
%    \If{$sym = \varepsilon$}
%        \ForAll{$q_0 \in I$}
%            \State $currentRow[q_0] \gets [(0, 0)]$
%        \EndFor
%    \Else
%        \State $nextRow \gets$ empty map
%        \If{$sym \in \Sigma$}
%            \ForAll{$q \in$ \textbf{keys}($currentRow$)}
%                % \State $transitions \gets \delta(q, sym)$
%                \If{$|\delta(q, sym)| > 0$}
%                    \ForAll{$q' \in \delta(q, sym)$}
%                        \ForAll{$(start, \_) \in currentRow[q]$}
%                            \If{$q' = q$ and $q' \in I$}
%                                \State append $(position, position)$ to $nextRow[q']$
%                            \Else
%                                \State append $(start, position)$ to $nextRow[q']$
%                                \If{$q' \in F$}
%                                    \State append $(start, position)$ to $finalMatches[q']$
%                                \EndIf
%                            \EndIf
%                        \EndFor
%                    \EndFor
%                \EndIf
%            \EndFor
%        \Else
%            \Comment{Symbol not in $\Sigma$; treat as fresh start}
%            \ForAll{$q_0 \in I$}
%                \State $nextRow[q_0] \gets [(position, position)]$
%            \EndFor
%        \EndIf
%        \State $currentRow \gets nextRow$
%        \State $position \gets position + 1$
%    \EndIf
%\EndFor
%\State \Return $finalMatches$
%\end{algorithmic}
%\end{small}
%\end{algorithm}

%\clearpage

\chapter{Matching}\label{chap:matching}
% Matching is used to search, validate, or extract parts of text based on these patterns. For example, a regex can be used to find all dates in a document or to ensure a password meets certain rules.

\emph{Matching} is the process of checking whether a piece of text fits a specific pattern described using a regular expression (regex).
In this chapter, we will discuss the different approaches to matching regular expressions and their differences, the implications of using them, and the performance considerations that arise from these choices. Furthermore, due to the importance of multiple matching and the lack of tools that accomplish it, we will also contribute with a novel approach based on a modified position automaton and matcher, with the focus of mitigating the performance issues associated with traditional regex engines while preserving some of the extended expressiveness of regex patterns.

\section{Multiple Matching}
\label{sec:multimatching}
The definition of single matching was introduced in Definition~\ref{defn:single_matching}. Now, the concept of multiple matching is simply to get all the matches of a given regular expression within an input text.
We can define it formally like so,
\begin{defn}
	Let $r \in RegExp(\Sigma)$, $(i,j) \in \Npos^2$ where $j>i$, and $t \in \Sigma^\star$.
	\begin{align*}
		\text{matches($r$, $t$)} = \{
			(i,j) \mid \exists w \in L(r), \ t \in \Sigma^i w \Sigma^j
		\}
	\end{align*}
\end{defn}
Informally, we want to capture the positions in $t$ where a matching substring is between a prefix of length $i$ and a suffix of length $j$.
In this chapter, we will use the term \textit{matching} to refer to \textit{multiple matching} or \textit{all matching}.

\section{Overlapped versus Non-Overlapped Matching}
\label{sec:overlap-vs-nonoverlap}

In the context of regular expression matching, two distinct paradigms exist: \emph{overlapped matching} and \emph{non-overlapped matching}. Understanding their differences is crucial when designing matching engines, especially when completeness or performance is a concern.

\subsection*{Overlapped Matching}
Overlapped matching refers to finding all possible matches of a pattern in an input string. This is typically achieved by attempting a match starting at every index of the input. It is more exhaustive and useful in domains where no potential match should be missed, such as bioinformatics (DNA pattern searching).

For example, the indexed string $w = a_0 a_1 a_2 a_3$, when matched against using the pattern $r=aa$, will yield the following matched substrings:

\begin{itemize}
	\item $w_{[0,2[} = {\color{red}{aa}}aa$
	\item $w_{[1,3[} = a{\color{red}{aa}}a$
	\item $w_{[2,4[} = aa{\color{red}{aa}}$
\end{itemize}

\subsection*{Non-Overlapped Matching}
Non-overlapped matching (also referred to as \emph{disjoint}, \emph{standard}, or in some engines, \emph{greedy} matching) finds matches sequentially from left to right, and once a match is found, it advances the input pointer beyond the match. Unlike overlapped matchers, where overlapping is a feature by default, greedy matchers will often depend on the lookahead assertions to do so.

Using the same pattern $r=aa$ on $w = a_0 a_1 a_2 a_3$, a non-overlapping matcher may return:

\begin{itemize}
	\item $w_{[0,2[} = {\color{red}{aa}}aa$
	\item $w_{[2,4[} = aa{\color{red}{aa}}$
\end{itemize}

As an example, this is the exact behaviour that PCRE2 demonstrates when trying to match for $aa$ on an input text $aaaa$.

To summarize, overlapped matching provides a more complete view of potential matches, but at a higher computational cost. It is particularly well-suited to automata-based approaches like the modified position automaton described in this work.


\section{Modified Position Automaton}
In order to perform multiple matching, we had to use a different automaton. A \emph{position automaton} is a construction that transforms a regular expression into a nondeterministic finite automaton (NFA) (\ref{chap:prelim:pos_auto}). The key component to this construction is the fact that each state corresponds to a position in the regular expression.
For instance, let $r = a^{2,4}$. This expression can be built using Brzozowski's derivatives construction. The resulting DFA can be seen below:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto,initial text=]
		\node[state,initial]            (q0) {0};
		\node[state]           [right=of q0] (q1) {1};
		\node[state,accepting] [right=of q1] (q2) {2};
		\node[state,accepting] [right=of q2] (q3) {3};
		\node[state]           [right=of q3] (q4) {4};
		
		\path[->]
		(q0) edge node {$a$} (q1)
		(q1) edge node {$a$} (q2)
		(q2) edge node {$a$} (q3)
		(q3) edge node {$a$} (q4)
		(q4) edge[loop above] node {$a$} ();
	\end{tikzpicture}
	\caption{DFA resulting from Brzozowski's derivatives construction for the expression $r=a^{2,4}$.}
\end{figure}
%Having an input text such as $w = aaa$, we should be able to match 3 distinct patterns using multiple matching. Trying with the DFA:
For single matching, a typical matcher should be able to match in $O(n)$ using this DFA, where $n$ is the length of the input string. However, this DFA does not allow for overlapped matching. The matcher would need to be restarted after each starting position, leading to a running time complexity of $O(n^2)$.
So, in order to perform overlapped matching in linear time, the automaton must be constructed using a modified position automaton construction.
%This means that we can't track the positions for each match, nor can we continually input text into the automaton.
%In order to track the position for each match, the position automaton construction must be modified. 
Using Algorithm~\ref{alg:nfaPosCount} to build an NFA for $r$ results in the NFA represented below:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt, node distance=2cm, on grid, auto, initial text=]
		\node[state, initial]            (q0) {0};
		\node[state]           [above right=of q0] (q1) {1};
		\node[state, accepting]           [right=of q1]       (q5) {5};
		\node[state] [right=of q5]      (q6) {6};
		\node[state]           [below right=of q0] (q2) {2};
		\node[state]           [right=of q2]       (q3) {3};
		\node[state, accepting] [right=of q3]      (q4) {4};
		
		% Transitions
		\path[->]
		(q0) edge[loop below] node {$a$} ()
		edge node {$a$} (q1)
		edge node {$a$} (q2)
		(q1) edge node {$a$} (q5)
		(q2) edge node {$a$} (q3)
		(q3) edge node {$a$} (q4)
		(q5) edge node {$a$} (q6)
		(q4) edge node {$a$} (q6)
		(q6) edge[loop right] node {$a$} ();
	\end{tikzpicture}
	\caption{NFA resulting from the modified position automaton construction for the expression $r=a^{2,4}$.}
\end{figure}
This NFA now contains two different branches, one that captures all the matches for $aa$ and another one that captures all the matches for $aaa$. Also, it can continuously match due to the loops on states $0$ and $6$.
To demonstrate the matcher logic, it is better to implement a more complex regular expression.
Consider the following regular expression $s$ and input word $w$:
\begin{center}
	$s = (aa+aaa)(aaa+aa)$ \break
	$w = aaaaabaaaaa$
\end{center}

We can separate $R$ into two matching groups:
\begin{itemize}
	\item The first group $(aa+aaa)$ will match either two or three $a$ symbols (e.g. $aaa$ will yield three overlapped matches: ${\color{red}{aa}}a$, $a{\color{red}{aa}}$ and ${\color{red}{aaa}}$).
	\item The second group $(aaa+aa)$ will also match either two or three $a$ symbols, much like the first group.
\end{itemize}

The normal position automaton construction for $s$ is as follows, considering the marked version $(a_1a_2+a_3a_4a_5)(a_6a_7a_8+a_9a_{10})$:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid, auto,initial text=]
		\node[state, initial] (q0) {$q_0$};
		\node[state] (q2) [above right=of q0] {$q_2$};
		\node[state] (q3) [right=of q2] {$q_3$};
		\node[state] (q4) [right=of q3] {$q_4$};
		\node[state] (q5) [right=of q4] {$q_5$};
		\node[state] (q8) [right=of q5] {$q_8$};
		\node[state,accepting] (q9) [right=of q8] {$q_9$};
		
		\node[state] (q1) [below right=of q0] {$q_1$};
		\node[state] (q10) [right=of q1] {$q_{10}$};
		\node[state] (q6) [right=of q10] {$q_6$};
		\node[state,accepting] (q7) [right=of q6] {$q_7$};
		
		\path[->]	(q0)	edge	node	{$a$} (q1)
		edge	node	{$a$} (q2)
		(q1)	edge	node	{$a$} (q10)
		(q10)	edge	node	{$a$} (q6)
		(q10)	edge	node	{$a$} (q5)
		(q6)	edge	node	{$a$} (q7)
		(q2)	edge	node	{$a$} (q3)
		(q3)	edge	node	{$a$} (q4)
		(q4)	edge	node	{$a$} (q5)
		(q4)	edge	node	{$a$} (q6)
		(q5)	edge	node	{$a$} (q8)
		(q8)	edge	node	{$a$} (q9);
	\end{tikzpicture}
	\caption{Unmodified position automaton construction of $s$}
\end{figure}


Meanwhile, the modified position automaton for this regular expression can be constructed using the Algorithm~\ref{alg:nfaPosCount}, resulting in the following:
\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid, auto,initial text=]
		\node[state, initial] (q0) {$q_0$};
		\node[state] (q2) [above right=of q0] {$q_2$};
		\node[state] (q3) [right=of q2] {$q_3$};
		\node[state] (q4) [right=of q3] {$q_4$};
		\node[state] (q5) [right=of q4] {$q_5$};
		\node[state] (q8) [right=of q5] {$q_8$};
		\node[state,accepting] (q9) [right=of q8] {$q_9$};
		
		\node[state] (q1) [below right=of q0] {$q_1$};
		\node[state] (q10) [right=of q1] {$q_{10}$};
		\node[state] (q6) [right=of q10] {$q_6$};
		\node[state,accepting] (q7) [right=of q6] {$q_7$};
		
		\node[state] (q11) [below right=of q9,right=of q7] {$q_{11}$};
		
		\path[->]	(q0)	edge	node	{$a$} (q1)
		edge	node	{$a$} (q2)
		edge [loop above] node {$\Sigma$} ()
		(q1)	edge	node	{$a$} (q10)
		(q10)	edge	node	{$a$} (q6)
		(q10)	edge	node	{$a$} (q5)
		(q6)	edge	node	{$a$} (q7)
		(q7)	edge	node	{$\Sigma$} (q11)
		(q2)	edge	node	{$a$} (q3)
		(q3)	edge	node	{$a$} (q4)
		(q4)	edge	node	{$a$} (q5)
		(q4)	edge	node	{$a$} (q6)
		(q5)	edge	node	{$a$} (q8)
		(q8)	edge	node	{$a$} (q9)
		(q9)	edge	node	{$\Sigma$} (q11)
		(q11)	edge [loop below] node {$\Sigma$} ();
	\end{tikzpicture}
	\caption{Modified position automaton construction of $s$}
	\label{fig:modified_glushkov_automaton}
\end{figure}


%One can then apply the matching algorithm (\ref{alg:table-matcher}) to an input string, resulting in the following match table:

When we match using Algorithm~\ref{alg:table-matcher} to an input string, it will traverse the automaton and record all positions where matches occur. This approach ensures that we can find all possible matches, including those that overlap, without falling into the exponential blowup trap of backtracking.

The result is a table that maps each accepting state to a set of index pairs, each indicating the start and end of a successful match. For instance, applying this process to $R = (aa+aaa)(aaa+aa)$ and $w = aaaaabaaaaa$ will yield the following table:

\begin{table}[H]
	\caption{Match positions table using the regular expression $R = (aa+aaa)(aaa+aa)$ and input string $w = aaaaabaaaaa$}
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|l|}
			\hline
			& $q_0$   & $q_1$   & $q_2$   & $q_3$   & $q_4$   & $q_5$   & $q_6$   & $q_7$   & $q_8$   & $q_9$   & $q_{10}$ & $q_{11}$ \\ \hline
			$\varepsilon$ & (0,0)   &         &         &        &        &         &         &         &         &        &          &          \\ \hline
			a         & (1,1)   & (0,1)   & (0,1)   &        &        &         &         &         &         &        &          &          \\ \hline
			a         & (2,2)   & (1,2)   & (1,2)   & (0,2)  &        &         &         &         &         &        & (0,2)    &          \\ \hline
			a         & (3,3)   & (2,3)   & (2,3)   & (1,3)  & (0,3)  & (0,3)   & (0,3)   &         &         &        & (1,3)    &          \\ \hline
			a         & (4,4)   & (3,4)   & (3,4)   & (2,4)  & (1,4)  & \begin{tabular}[c]{@{}l@{}}(0,4)\\ (1,4)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(0,4)\\ (1,4)\end{tabular}
			& (0,4)   & (0,4)   &        & (2,4)    &          \\ \hline
			a         & (5,5)   & (4,5)   & (4,5)   & (3,5)  & (2,5)  & \begin{tabular}[c]{@{}l@{}}(1,5)\\ (2,5)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(1,5)\\ (2,5)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(1,5)\\ (0,5)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(1,5)\\ (0,5)\end{tabular}
			& (0,5)  & (3,5)  & (0,5)    \\ \hline
			b         & (6,6)   &         &         &        &        &         &         &         &         &        &          &          \\ \hline
			a         & (7,7)   & (6,7)   & (6,7)   &        &        &         &         &         &         &        &          &          \\ \hline
			a         & (8,8)   & (7,8)   & (7,8)   & (6,8)  &        &         &         &         &         &        & (6,8)    &          \\ \hline
			a         & (9,9)   & (8,9)   & (8,9)   & (7,9)  & (6,9)  & (6,9)   & (6,9)   &         &         &        & (7,9)    &          \\ \hline
			a         & (10,10) & (9,10)  & (9,10)  & (8,10) & (7,10) & \begin{tabular}[c]{@{}l@{}}(6,10)\\ (7,10)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(6,10)\\ (7,10)\end{tabular}
			& (6,10)  & (6,10)  &        & (8,10) &          \\ \hline
			a         & (11,11) & (10,11) & (10,11) & (9,11) & (8,11) & \begin{tabular}[c]{@{}l@{}}(7,11)\\ (8,11)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(7,11)\\ (8,11)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(6,11)\\ (7,11)\end{tabular}
			& \begin{tabular}[c]{@{}l@{}}(6,11)\\ (7,11)\end{tabular}
			& (6,11) & (9,11) & (6,11)   \\ \hline
		\end{tabular}
	}
	\label{fig:pos_match_tbl}
\end{table}


First, we always have to account for $\varepsilon$, since there is the possibility of having the empty word and we also want to match against it.
After that, every symbol $s \in w$ is processed sequentially.

At each step, the algorithm updates a row that maps the automaton's (represented in Figure~\ref{fig:modified_glushkov_automaton}) states to sets of position intervals $(i,j)$, such that the substring $w_{ij}$ corresponds to a valid match, whether it is overlapped or not.

Transitions are computed for each input symbol using the automaton's $\delta$ function. When a final state is reached, the interval is stored as a successful match. Furthermore, during this process, only the last symbol's computed transitions and position intervals are preserved because they always carry over to the current symbol's computation.

The automaton on Figure~\ref{fig:modified_glushkov_automaton} shows that:

\begin{center}
	$F = \{q_7, q_9\}$
\end{center}

For those states, the resulting match table is represented by Table~\ref{tab:left-highlights} and Table~\ref{tab:left-highlights1}.

\begin{table}[H]
	\centering
	\renewcommand{\arraystretch}{1.2}
	
	\begin{minipage}[t]{0.48\textwidth}
		\caption{Highlighted substrings of valid matches for state $q_7$}
		\centering
		\begin{tabular}{|c|>{\ttfamily}l|}
			\hline
			$w_{0,4}$  & \textbf{\textcolor{red}{aaaa}}\textbf{abaaaaa} \\ \hline
			$w_{0,5}$  & \textbf{\textcolor{red}{aaaaa}}\textbf{baaaaa} \\ \hline
			$w_{1,5}$  & \textbf{a}\textbf{\textcolor{red}{aaaa}}\textbf{baaaaa} \\ \hline
			$w_{6,10}$ & \textbf{aaaaab}\textbf{\textcolor{red}{aaaa}}\textbf{a} \\ \hline
			$w_{6,11}$ & \textbf{aaaaab}\textbf{\textcolor{red}{aaaaa}} \\ \hline
			$w_{7,11}$ & \textbf{aaaaaba}\textbf{\textcolor{red}{aaaa}} \\ \hline
		\end{tabular}
		\label{tab:left-highlights}
	\end{minipage}\hfill
	%
		\begin{minipage}[t]{0.48\textwidth}
		\caption{Highlighted substrings of valid matches for state $q_9$}
		\centering
		\begin{tabular}{|c|>{\ttfamily}l|}
			\hline
			$w_{0,5}$  & \textbf{\textcolor{red}{aaaaa}}\textbf{baaaaa} \\ \hline
			$w_{6,11}$ & \textbf{aaaaab}\textbf{\textcolor{red}{aaaaa}} \\ \hline
		\end{tabular}
		\label{tab:left-highlights1}
	\end{minipage}
\end{table}

As seen in the tables, we are able to get all the matches possible (even overlapped ones) for the given input word $w$, along with their positions.

\section{Implementation in FAdo}
In order to support these new operations in \textit{FAdo}, a new class was created. This new \texttt{matchNFA} class inherits from the \texttt{NFA} class. In it, several methods were implemented.
\begin{lstlisting}[language=Python]
	class matchNFA(NFA):
		def __init__(self):
			NFA.__init__(self)
		
		def table_matcher(self, input_text: str):
			...
			
		def enum_matches(self, match_table: dict, input_text: str):
			match_count = 0
			for entry in pos_tab:
				print(f"State {entry} matches ({len(set(pos_tab[entry]))}):")
				match_set = set(pos_tab[entry])
				match_count += len(match_set)
				for match in sorted(match_set):
					first_index = string[0:match[0]]
					second_index = string[match[1]:]
					print("Match:", colored(first_index, 'red') + colored(string[match[0]:match[1]], 'green') + colored(second_index, 'red'), "=>", match)
			print("Total matches:", match_count)
	
	def nfaPosCount(self: RegExp):
		...
	
	setattr(RegExp, "nfaPosCount", nfaPosCount)
\end{lstlisting}

\begin{itemize}
	\item \texttt{table\_matcher} is the algorithm (can be seen in Table~\ref{alg:table-matcher}) that creates the matching table, 
	\item \texttt{enum\_matches} is the algorithm that displays the formatted matching table data,
	\item \texttt{nfaPosCount} is the modified position automaton builder (can be seen in Algorithm~\ref{alg:nfaPosCount}).
\end{itemize}

The \texttt{nfaPosCount} function is defined outside of \texttt{matchNFA}'s scope because, even though it can be fully integrated into \texttt{FAdo}, it still isn't. The \texttt{setattr} function is used to add this method to the \texttt{RegExp} class after it has been defined, so that it can later be used in other components of \texttt{FAdo}.

\section{Limitations}
There are some caveats regarding this modified position automaton construction and the table-based matcher.

\subsection{Match Table Size}
The match table can grow large. Practically, each input symbol will result in a new "step" in the table. Each step on the table will store data for multiple states (some can be empty, but they fill up continually). In the worst case, meaning that there are positions for each of the states, this will scale with the number of states.
Ultimately, storing sets of intervals per state per position is done with space complexity of $O(m \cdot n)$, where $m$ is the total number of states and $n$ is the length of the input text.

\subsection{Construction Size}
Although the position automaton construction is linear in the number of symbol occurrences, bounded repetitions such as $a^{m,n}$ get unrolled into $a^m + a^{m+1} + \cdots + a^n$. Therefore, large bounds or nested counts will inflate the automaton and, therefore, slow down its construction.
Having the regular expression $a^{1,50}$, for instance. Figure~\ref{fig:shortened_large_automaton} represents a shortened version of this construction.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt,node distance=1.8cm,on grid,auto,initial text=]
		\node[state, initial] (q0) at (0,0) {$q_0$};
		\node[state] (qfin) at (10,0) {$q_n$};
		
		\node[state, accepting] (q1) at (1.5,3) {$q_1$};
		
		\node[state] (q2) at (1.5,2) {$q_2$};
		\node[state, accepting] (q20) at (3,2) {$q_{20}$};
		
		
		\node[state] (q3) at (1.5,1) {$q_3$};
		\node[state] (q30) at (3,1) {$q_{30}$};
		\node[state, accepting] (q31) at (4.5,1) {$q_{31}$};
		
		\node[state] (q4) at (1.5,0) {$q_4$};
		\node[state] (q40) at (3,0) {$q_{40}$};
		\node[state] (q41) at (4.5,0) {$q_{41}$};
		\node[state, accepting] (q42) at (6,0) {$q_{42}$};
		
		\node (qj) at (5,-1) {$\cdots$};
		
		\path[->]
		(q0) edge [loop below] node {$a$} ()
		edge [bend left=2.5cm] node {$a$} (q1)
		edge [bend left=2cm] node {$a$} (q2)
		edge [bend left] node {$a$} (q3)
		edge node {$a$} (q4)
		edge [bend right=0.5cm] node {$a$} (qj)
		
		(qj) edge [bend right=0.5cm] node {$a$} (qfin)
		
		(q2) edge node {$a$} (q20)
		
		(q3) edge node {$a$} (q30)
		(q30) edge node {$a$} (q31)
		
		(q4) edge node {$a$} (q40)
		(q40) edge node {$a$} (q41)
		(q41) edge node {$a$} (q42)
		
		(q1) edge [bend left=0.7cm] node {$a$} (qfin)
		(q20) edge [bend left=0.5cm] node {$a$} (qfin)
		(q31) edge [bend left=0.3cm] node {$a$} (qfin)
		(q42) edge node {$a$} (qfin)
		
		(qfin) edge [loop below] node {$a$} ()
		;
	\end{tikzpicture}
	\caption{Abbreviated representation of the large modified position automaton.}
	\label{fig:shortened_large_automaton}
\end{figure}

Any automatons constructed for a regular expression that are constituted by a singe bounded repetition operator such as $a^{n,m}$ will have $\sum_{n=1}^{m-1} n + 2$ states. Therefore, the automaton for the expression $a^{1,50}$ contains 1227 states.

It is important to note that bounded repetitions are the worst case scenario for this construction. This blow up does not usually happen with the other operators.

%\section{Other Implementations}




%Recalling the regular expression used $R = (aa+aaa)(aaa+aa)$ and input string $w = aaaaabaaaaa$, 

%As shown in \ref{fig:pos_match_tbl}, the algorithm parses every input symbol. 

%The highlighted columns are the so called "tracking states".
%
%This output demonstrates that the modified automaton not only supports detection of all valid matches for a given regular expression but also accurately identifies overlapping occurrences—something traditional engines either fail to do or achieve with substantial computational overhead.
%
%Because this construction is built on a finite automaton and avoids recursive or backtracking search, its runtime remains linear with respect to the input length, multiplied by the number of active states. This provides robust resistance to ReDoS attacks while retaining flexibility in expressiveness and matching semantics.
%
%Moreover, by storing match ranges, this method facilitates advanced text analysis tasks such as syntax highlighting, pattern-based replacements, and deep parsing, where knowing the exact span of each match is essential.
%
%In the next chapter, we evaluate the performance characteristics of this approach and compare it against classical backtracking and DFA-based engines under different conditions and input patterns.


% When we apply the matching algorithm (\ref{alg:table-matcher}) to an input string, it will traverse the automaton and record all positions where matches occur. This approach ensures that we can find all possible matches, including those that overlap, without falling into the exponential blowup trap of backtracking.