\chapter{Counting}\label{chap:counting}
In this chapter, we will explore the concept of counting in the context of formal languages and automata theory as well as explain the implementation for fixed and bounded repetition in FAdo.

\section{Counting in Formal Languages}
In formal language theory, counting refers to the ability of a language or an automaton to enforce numeric constraints over the number of symbols or patterns within strings. Specifically, it deals with the ability to recognize whether certain elements occur a specified number of timesâ€”or in a specific numerical relationship to others.
Current tools are already able to do this, including some non-backtracking matchers. However, even for tools based on NFA and DFA, these operators are problematic due to the complexity of their manipulation. The aim of the work here described is to build derivative-based tools that may be more efficient and/or secure. 

\section{Derivatives of fixed and bounded repetition operators} %TODO: CHANGE THIS
Given a word $w$ and a regular expression $e$, $w \in L(e)$ if $\varepsilon(d_w(e)) = \varepsilon$.
In order to match with fixed and bounded repetition using derivatives, one must first define them for those operations.

\begin{thm}
	Given $e \in RegExp(\Sigma)$, the following holds:
	\begin{align*}
		\varepsilon(e) + e = e
	\end{align*}
\end{thm}
\begin{proof}
	Let $e \in RegExp(\Sigma)$. The proof considers the cases where $\varepsilon \in L(e)$ and $\varepsilon \notin L(e)$.
	For $\varepsilon \in L(e)$, we have that $\varepsilon(e) = \varepsilon$. And then,
	\begin{align*}
		& \varepsilon(e) + e = e \\
		& \Rightarrow \varepsilon + e = e \\
		& \Rightarrow e = e
	\end{align*}
	holds. On the other hand, for $\varepsilon \notin L(e)$, we have that $\varepsilon(e) = \emptyset$. Therefore,
	\begin{align*}
		& \varepsilon(e) + e = e \\
		& \Rightarrow \emptyset + e = e \\
		& \Rightarrow e = e
	\end{align*}
	also holds.
\end{proof}

\subsection{Fixed Repetition}
%For a fixed repetition, we need $r$ to occur $n$ times, resulting in the notion $r^n$.

% PROOF
%\begin{thm}
%	Given $e \in RegExp(\Sigma)$ and $n \in \Npos$, we have that
%	\begin{align*}
%		d_a(e^n) = d_a(e)e^{n-1}
%	\end{align*}
%	is true.
%\end{thm}
%\begin{proof}
%	Let $e \in RegExp(\Sigma)$ and $n \in \Npos$. The following holds:
%	\begin{align*}
%		d_a(e) = d_a(e)e^0 = d_a(e)
%	\end{align*}
%	We can also suppose that
%	\begin{align*}
%		d_a(e^{n-1}) = d_a(e)e^{n-2}
%	\end{align*}
%	And so, we can use the results above to do the following:
%	\begin{align*}
%		d_a(e^n) &= d_a(ee^{n-1}) \\
%		&= d_a(e)e^{n-1} + \varepsilon(e)d_a(e^{n-1}) \\
%		&= d_a(e)e^{n-1} + \varepsilon(e)d_a(e)e^{n-2} \\
%		&= (d_a(e)e + \varepsilon(e)d_a(e))e^{n-2} \\
%		&= (d_a(e)(e+\varepsilon(e)))e^{n-2} \\
%		&= d_a(e)e^{n-1}
%	\end{align*}
%\end{proof}
\begin{thm}
	\label{thm:fixed_repetition_derivative}
	Given $e \in RegExp(\Sigma)$ and $n \in \Npos$, we have:
	\begin{align*}
		d_a(e^n) = d_a(e)\,e^{n-1}.
	\end{align*}
\end{thm}

\begin{proof}
	We proceed by induction on $n \in \Npos$. For the base case \( n = 1 \),
	\begin{align*}
		d_a(e^1) = d_a(e) = d_a(e)e^0 = d_a(e)\varepsilon = d_a(e).
	\end{align*}
	Since the identity holds for \(n = 1\), lets assume that the identity holds for some \(n-1 \geq 1\), i.e.,
	\begin{align*}
		d_a(e^{n-1}) = d_a(e)e^{n-2}.
	\end{align*}
	We want to show it holds for \(n\). Using the product rule:
	\begin{align*}
		d_a(e^n) &= d_a(ee^{n-1}) \\
		&= d_a(e) e^{n-1} + \varepsilon(e) d_a(e^{n-1}) \\
		&= d_a(e) e^{n-1} + \varepsilon(e) d_a(e) e^{n-2} \\
		&= d_a(e) \left(e^{n-1} + \varepsilon(e) e^{n-2}\right) \\
		&= d_a(e) \left(ee^{n-2} + \varepsilon(e) e^{n-2}\right) \\
		&= d_a(e) (e + \varepsilon(e))e^{n-2} \\
		&= d_a(e) e^{n-1}.
	\end{align*}
	This completes the induction.
\end{proof}

As an example, let $e = ab$ such that $e^2 = abab$. Using the theorem above:
\begin{align*}
	d_a(e^2) &= d_a(e)e \\
	&= d_a(ab)ab  \\
	&= bab
\end{align*}

% ADD e^n results for n=0, n=1 and n>1

We can also define partial derivatives and the linear form for this new operator. We have
\begin{gather*}
	\partial_a(e^n) = \partial_a(e)e^{n-1} \\
	lf(e^n) = lf(e)e^{n-1}
\end{gather*}
for $e \in RegExp(\Sigma)$, $a \in \Sigma$, and $n \in \Npos$.

\subsection{Bounded Repetition}
%Supplementing the fixed repetition notion, we now add a maximum bound so that $r$ can occur at least $n$ times and at maximum $m-1$ times: $r^{n,m}$.

\begin{thm}
	Given $e \in RegExp(\Sigma)$, $n \in \Npos$, $m > n$, and $a \in \Sigma$, we have:
	\begin{align*}
		d_a(e^{n,m}) =
		\begin{cases}
			d_a(e) e^{n-1,m-1}, & \text{if } n > 1, \\
			d_a(e) + d_a(e) e^{1,m-1}, & \text{if } n = 1.
		\end{cases}
	\end{align*}
\end{thm}

\begin{proof}
	Let $e \in RegExp(\Sigma)$ and let $n, m \in \Npos$ with $m > n$. By definition of bounded iteration:
	\begin{align*}
		e^{n,m} &= \sum_{i=n}^{m} e^i,
	\end{align*}
	and by the linearity of derivatives over sums:
	\begin{align*}
		d_a(e^{n,m}) &= \sum_{i=n}^{m} d_a(e^i).
	\end{align*}
	Using the known identity $d_a(e^i) = d_a(e) e^{i-1}$, we have:
	\begin{align*}
		d_a(e^{n,m}) &= \sum_{i=n}^{m} d_a(e) e^{i-1} \\
		&= d_a(e) \sum_{i=n}^{m} e^{i-1}.
	\end{align*}
	Letting $j = i - 1$, this becomes:
	\begin{align*}
		d_a(e^{n,m}) &= d_a(e) \sum_{j=n-1}^{m-1} e^j = d_a(e) e^{n-1,m-1}.
	\end{align*}
	Considering both cases, for $n > 1$, the expression is already in its final form:
	\begin{align*}
		d_a(e^{n,m}) = d_a(e) e^{n-1,m-1}.
	\end{align*}
	And for $n = 1$, we have:
	\begin{align*}
		d_a(e^{1,m}) &= d_a(e) e^{0,m-1} \\
		&= d_a(e) + d_a(e) e^{1,m-1}.
	\end{align*}
	This completes the proof.
\end{proof}
Furthermore, we can include the infinite upper bound: $e^{n,\infty}$.
\begin{align*}
	e^{n,\infty} = e^ne^\star
\end{align*}
We can simplify it even more, depending on the value of $n$. Assuming $n=0$:
\begin{align*}
	e^{0,\infty} = e^0e^\star = \varepsilon e^\star =  e^\star
\end{align*}
Lastly, for $n=1$:
\begin{align*}
	e^{1,\infty} = e^1e^\star = ee^\star =  e^+
\end{align*}

These relations allow to substitute $r^\star$ and $r^+$ with counting expressions. However, in the \emph{FAdo} package, we consider also the classic iterators.

\begin{thm}
	Given $e \in RegExp(\Sigma)$, $n \in \N$ and $a \in \Sigma$, we have:
	\begin{align*}
		d_a(e^{n,\infty}) =
		\begin{cases}
			d_a(e)e^{n-1, \infty}, & \text{if } n>0, \\
			d_a(e)e^{0, \infty}, & \text{otherwise}.
		\end{cases}
	\end{align*}
\end{thm}
\begin{proof}
	Let $e \in RegExp(\Sigma)$, $n \in \N$, and $a \in \Sigma$. We have,
	\begin{align*}
		d_a(e^{n,\infty}) &= d_a(e^ne^\star) \\
		&= d_a(e^n)e^\star + \varepsilon(e)d_a(e)e^\star \\
		&= (d_a(e^n) + \varepsilon(e)d_a(e))e^\star \\
		&= (d_a(e)e^{n-1} + d_a(e) \varepsilon(e))e^\star \\
		&= (d_a(e)(e^{n-1} + \varepsilon(e)))e^\star \\
		&= d_a(e)e^{n-1}e^\star \\
		&= d_a(e)e^{n-1, \infty}.
%		&= d_a(e^n)e^\star. %\\
%		\intertext{using \ref{thm:fixed_repetition_derivative}:}
%		&= d_a(e)e^{n-1}e^\star
%	\end{align*}
%	Now, using \ref{thm:fixed_repetition_derivative}:
%	\begin{align*}
%		d_a(e^n)e^\star = d_a(e)e^{n-1}e^\star = d_a(e)e^{n-1, \infty}.
	\end{align*}
	Otherwise, if $n=0$, we can just replace accordingly:
	\begin{align*}
		d_a(e^ne^\star) = d_a(e^0e^\star) = d_a(e^\star) = d_a(e)e^\star = d_a(e)e^{0, \infty}.
	\end{align*}
	This concludes the proof.
\end{proof}
For instance, given $e = ab$ such that $e^2 = abab$ and $e^3 = ababab$, we have:
\begin{align*}
	d_a(e^{2,4}) &= d_a(e)e^{[1,3[} \\
	&= b(ab)^{[1,3[} \\
	&= bab + babab
%	d_a(r^{2,4}) &= d_a(abab) + d_a(ababab) \\
%	&= d_a(abab) + d_a(ababab) \\
%	&= d_a(a)bab + d_a(bab) + d_a(a)babab + d_a(babab) \\
%	&= \varepsilon bab + \emptyset + babab + \emptyset \\
%	&= bab + babab.
\end{align*}
Extending to the infinity case, $e^{2, \infty}$:
\begin{align*}
	d_a(e^{2, \infty}) &= d_a(e)e^{1, \infty} \\
	&= b(ab)e^{1,\infty} \\
	&= bab + b(ab)^+
%	d_a(r^{[2,\inf[}) &= d_a(abab) + d_a((ab)^*) \\
%	&= d_a(a)bab + d_a(bab) + d_a(ab)\cdot(ab)^* \\
%	&= \varepsilon bab + \emptyset + (d_a(a)b + d_a(b)) \cdot (ab)^* \\
%	&= bab + (\varepsilon b + \emptyset) \cdot (ab)^* \\
%	&= bab + b(ab)^*.
\end{align*}

Lastly, we can define the partial derivatives and linear form for these operators too.
We have for bounded repetition (excluding infinity cases),
\begin{align*}
	\partial_a(e^{n,m}) &= \begin{cases}
		\partial_a(e)e^{n-1,m-1}, & \text{if $n > 1$}, \\
		\partial_a(e) + \partial_a(e)e^{1,m-1}, & \text{if $n=1$}.
	\end{cases} \\
	lf_a(e^{n,m}) &= \begin{cases}
		lf_a(e)e^{n-1,m-1}, & \text{if $n > 1$}, \\
		lf_a(e) + lf_a(e)e^{1,m-1}, & \text{if $n=1$}.
	\end{cases} \\
\intertext{and for its infinity cases,}
	\partial_a(e^{j,\infty}) &= \begin{cases}
		\partial_a(e)e^{j-1, \infty}, & \text{if $j > 0$}, \\
		\partial_a(e)e^{0, \infty}, & \text{otherwise}.
	\end{cases} \\
	lf_a(e^{j,\infty}) &= \begin{cases}
		lf_a(e)e^{j-1, \infty}, & \text{if $j > 0$}, \\
		lf_a(e)e^{0, \infty}, & \text{otherwise}.
	\end{cases}
%	\partial_a(e^n) = \partial_a(e)e^{n-1} \\
%	lf(e^n) = lf(e)e^{n-1}
\end{align*}
for bounded repetition, with $e \in RegExp(\Sigma)$, $a \in \Sigma$, $n \in \Npos$, $m>n$, $j \in \N$.

%For instance, if $m = 2$, we have that $r^{[2, \inf[}$

%The regular expression $r^{[2, \inf[}$ will match any $(ab)^k$ with $k \geq 2$.

%Given $w = abababab$ and $m = 2$,  will match 

%The string $abababab$ can be matched by $r^{[2, \inf[}$

%\begin{thm}
%	Given $e \in RegExp(\Sigma)$, $n \in \Npos$ and $m>n$, we have that
%	\begin{align*}
%	%	d_a(e^{n,m}) = d_a(e) e^{n-1,m-1}
%	d_a(e^{n,m}) = \begin{cases}
%		d_a(e)e^{n-1,m-1} & n>1 \\
%		d_a(e)+(d_a(e))e^{1,m-1} & n=1
%	\end{cases}
%	\end{align*}
%	is true.
%\end{thm}
%\begin{proof}
%	Let $e \in RegExp(\Sigma)$. We first need to simplify the main expression:
%	\begin{align*}
%		d_a(e^{n,m}) &= \sum_{i=n}^{m} d_a(e^i) \\
%		&= \sum_{i=n}^{m} (d_a(e))e^{i-1} \\
%		&= d_a(e) \sum_{j=n-1}^{m-1} e^j \\
%		&= d_a(e) e^{n-1,m-1}
%	\end{align*}
%	Thus, for $n=1$, we have that
%	\begin{align*}
%		d_a(e^{n,m}) &= d_a(e)e^{0,m-1} \\
%		&= d_a(e) + (d_a(e))e^{1,m-1}
%	\end{align*}
%	And lastly, for $n>=1$ we have that
%	\begin{align*}
%		d_a(e^{n,m}) &= (d_a(e))e^{n-1,m-1}
%	\end{align*}
%\end{proof}

%For instance, if $m = 2$, we have that $r^{[2, \inf[}$

%The regular expression $r^{[2, \inf[}$ will match any $(ab)^k$ with $k \geq 2$.

%Given $w = abababab$ and $m = 2$,  will match 

%The string $abababab$ can be matched by $r^{[2, \inf[}$


\section{Implementation in FAdo}
In order to implement these new syntactic constructs of extended regular expressions in FAdo, we added exact-power and counted-repetition nodes to the regular expression abstract syntax tree and define their derivatives, partial derivatives and linear form cases.

\subsection{CPower}
\textit{CPower} is the class responsible for the construction of regular expressions using the fixed repetition operator.

\begin{lstlisting}[language=Python]
class CPower(Unary):
	def __init__(self, arg, n, sigma=None):
	self.arg = arg
	self.n = n
	self.Sigma = sigma
	self._ewp = False if self.n > 0 else True
	
	...
\end{lstlisting}

As shown above, the class inherits from the \textit{Unary} class, which only defines the \textit{Unary.Sigma} and \textit{Unary.arg} properties, letting the class hold a alphabet set (representing $\Sigma$) and the symbol used to construct this operator.
In order to integrate \textit{CPower} fully with \textit{FAdo}, some more methods had to be implemented.

\begin{lstlisting}[language=Python]
	def linearForm(self):
		arg_lf = self.arg.linearForm()
		lf = dict()
		for head in arg_lf:
			lf[head] = set()
			for tail in arg_lf[head]:
				lf[head].add(self.derivative(head))
		return lf

	def partialDerivatives(self, sigma):
		return self.arg.partialDerivatives(sigma)
	
	def derivative(self, sigma):
		if str(sigma) in str(self.Sigma):
			if self.n == 0:
				return CEmptySet(sigma)
			elif self.n == 1:
				return self.arg.derivative(sigma)
			else:
				return CConcat(self.arg.derivative(sigma), CPower(self.arg, self.n-1, self.Sigma))
		else:
			return CEmptySet(sigma)
\end{lstlisting}

\subsection{CCount}
\textit{CCount} is the class responsible for the construction of regular expressions using the bounded repetition operator.


\begin{lstlisting}[language=Python]
	class CCount(Unary):
		def __init__(self, arg, min, max = None, sigma = None):
			self.arg = arg
			self.min = int(min)
			self.max = "inf" if max == -1 or max == "inf" else int(max)-1
			self.Sigma = sigma
	
			if self.min==0:
				self._ewp = True
\end{lstlisting}

As shown above, and much like \textit{CPower}, the class also inherits from \textit{Unary}. The constructor adjusts the bounds accordingly and sets the empty word property based on whether the minimum repetition is zero.

To fully integrate the class with \textit{FAdo}, several methods are implemented, including string representation, partial derivatives, linear form computation, and marking functions:

\begin{lstlisting}[language=Python]
	def derivative(self, sigma):
		if str(sigma) in str(self.Sigma):
			if self.max == "inf" or self.max == None:
				if self.min == 0:
					return CConcat(self.arg.derivative(sigma), CStar(self.arg, self.Sigma))
				else:
					return CConcat(self.arg.derivative(sigma), CCount(self.arg, self.min-1, self.max, sigma), self.Sigma)
			else:
				if self.max > 1:
					if self.min == 0:
						return CConcat(self.arg.derivative(sigma), CCount(self.arg, self.min, int(self.max), self.Sigma))
					else:
						return CConcat(self.arg.derivative(sigma), CCount(self.arg, self.min-1, int(self.max), self.Sigma))
				elif self.max == 1:
					return self.arg.derivative(sigma)
				else:
					CEpsilon(sigma)
		else:
			return CEmptySet(sigma)
		
	def partialDerivatives(self, sigma):
		arg_pdset = self.arg.partialDerivatives(sigma)
		pds = set()
		for pd in arg_pdset:
			if pd.emptysetP():
				pds.add(CEmptySet(self.Sigma))
			elif pd.epsilonP():
				pds.add(self)
			else:
				pds.add(CConcat(pd, self, self.Sigma))
		return pds
\end{lstlisting}

The \texttt{linearForm} method is exactly the same as \texttt{CPower}'s.

%\begin{lstlisting}[language=Python]
%	def linearForm(self):
%		arg_lf = self.arg.linearForm()
%		lf = dict()
%		for head in arg_lf:
%			lf[head] = set()
%			for tail in arg_lf[head]:
%				lf[head].add(self.derivative(head))
%		return lf
%\end{lstlisting}

\subsection{Grammar}
For ease of use and protoyping, we utilized \textit{FAdo}'s ability to parse a regular expression using a common Python \textit{string}. To do this, \textit{FAdo} utilizes a library called Lark. Lark is a modern, fast and flexible parsing toolkit for Python that supports both LALR(1) and Earley parsers, enabling the parsing of all context-free grammars with features like EBNF, AST generation, and grammar composition \cite{lark_parser}.
The new grammar can be seen in Appendix~\ref{appendix:regexp_lark} and the most notable changes are the following:
\begin{lstlisting}
	| rep _CARET _LEFBR digit _RIGBR -> pow_min
	| rep _CARET _LEFBR digit _COMMA digit _LEFBR -> pow_minmax
	| rep _CARET _LEFBR digit _COMMA _INFTY _LEFBR -> pow_inf
\end{lstlisting}
These rules (along with some more utilitary definitions such as the \texttt{\_LEFBR} and \texttt{\_RIGBR}, which are the symbols '\texttt{\string[}' and '\texttt{\string]}') will route the following cases (code in Appendix~\ref{appendix:regexp_builders}):
\begin{itemize}
	\item \textbf{pow\_min}: For the cases $e^{n}$ and $e^{n,\infty}$, where $e \in RegExp(\Sigma)$ and $n \in \Npos$
	\item \textbf{pow\_minmax}: For the case $e^{n,m}$, where $e \in RegExp(\Sigma)$ and $n \in \Npos, m>n$
	\item \textbf{pow\_inf}: Calls \textit{pow\_min} with a special argument that selects the infinity case
\end{itemize}

\subsection{Matching}
To demonstrate how matching is performed using the implemented operators, we can consider a concrete example.
For instance, let $r = (ab)^{1,3}$. The following code snippet shows how this expression can be parsed, transformed into an internal representation, and converted into a DFA using Brzozowski's construction:
%In order to match using these implemented notions, we can do as follows. . We can parse the regular expression and display it like so:
\begin{lstlisting}[language=Python]
	r = "(ab)^[1,3["
	tree = regGrammar.parse(r)
	reg : RegExp = BuildRegexp(context={"sigma": None}).transform(tree)
	reg.setSigma(reg.setOfSymbols())
	dfa_z = reg.dfaBrzozowski()
	dfa_z.display()
\end{lstlisting}

\begin{figure}[H]
	\centering
	\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid, auto,initial text=]
		
		% --- States ---
		\node[state, initial] (q0) {0};
		\node[state]          (q1) [above right=of q0] {1};
		\node[state]          (q2) [below right=of q0] {2};
		\node[state, accepting]         (q3) [right=22mm of q1] {3};
		\node[state]          (q4) [right=22mm of q2] {4};
		\node[state]          (q5) [above right=of q3] {5};
		\node[state]          (q6) [right=20mm of q3] {6};
		\node[state, accepting]         (q7) [right=22mm of q6] {7};
		\node[state]          (q8) [right=22mm of q7] {8};
		
		% --- Transitions ---
		\path[->]
		(q0) edge node {$b$} (q1)
		edge[swap] node {$a$} (q2)
		
		(q1) edge[loop above] node {$b, a$} ()
		
		(q2) edge node {$b$} (q3)
		edge[swap] node {$a$} (q4)
		
		(q4) edge[loop below] node {$b, a$} ()
		
		(q3) edge node {$b$} (q5)
		edge[swap] node {$a$} (q6)
		
		(q5) edge[loop above] node {$b, a$} ()
		
		(q6) edge node {$b$} (q7)
		edge[bend right=40, swap] node {$a$} (q8)
		
		(q7) edge node {$b, a$} (q8)
		
		(q8) edge[loop right] node {$b, a$} ();
	\end{tikzpicture}
	\caption{Diagram of the DFA built using Brzozowski's method for the regular expression $r = (ab)^{1,3}$.}
	\label{fig:dfa_brzozowski_counting}
\end{figure}


Then, try to match $w = ab$ using the same code from the snippet~\ref{code:eval_word_dfa}, which yields the following:
\begin{lstlisting}[language=Python]
	w belongs to the language of r
\end{lstlisting}
Trying again with a text that does not match, $w = ababab$, yields:
\begin{lstlisting}[language=Python]
	w does not belong to the language of r
\end{lstlisting}
%Formally, .