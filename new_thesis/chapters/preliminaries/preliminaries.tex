\chapter{Preliminaries}\label{chap:prelim}
Theory builds upon theory, therefore it is essential to establish a solid foundation by understanding the basic concepts and terminology that compose the core topics of formal languages and automata theory.
In this chapter we begin by formally defining what a language is and then move on to describe the class of languages known as regular languages.
Along the way, we will also introduce various concepts such as finite/non-finite automata and regular expressions.

\section{Alphabets, Strings and Languages}
\subsection*{Alphabets}

An \emph{alphabet} is a finite, non-empty set of symbols, typically denoted by the Greek letter $\Sigma$. That is,
\[
\Sigma = \{ a_1, a_2, \dots, a_n \}
\]

\noindent where each $a_i$ is a symbol in the alphabet.

For example, one can represent the binary alphabet as $\Sigma = \{ 0, 1 \}$, or the English alphabet as $\Sigma = \{ a, b, c, \ldots, z \}$.

\subsection*{Strings}
A \emph{string} over an alphabet $\Sigma$ is a finite sequence of symbols from $\Sigma$. Strings are typically denoted by $w$, and the \emph{length} of a string $w$ is denoted by $|w|$.

The set of all strings over the alphabet $\Sigma$ is denoted by $\Sigma^*$ and defined as:
\[
\Sigma^* = \{ w \mid w \text{ is a finite sequence of symbols from } \Sigma \}
\]

The unique string of length zero is called the \emph{empty string}, denoted by $\varepsilon$.
It is important to note that $\varepsilon \in \Sigma^*$.

For example, if $\Sigma = \{ 0, 1 \}$, then we have that:
\begin{center}
	$\Sigma^* = \{ \varepsilon, 0, 1, 00, 01, 10, 11, 000, 001, 010, 011, 100, 101, 110, 111, \ldots \}$
\end{center}

Where the empty string is, as mentioned above, denoted by $\varepsilon$ and also belongs to $\Sigma^*$.

\subsection*{Languages}

A \emph{language} over an alphabet $\Sigma$ is a set of strings over $\Sigma$.

\[
L \subseteq \Sigma^*
\]

That is, a language is any subset of $\Sigma^*$, possibly infinite, finite, or even empty. \newline
Since a language is a set of strings, the following standard set operations can be applied: % such as \emph{union}, \emph{intersection}, and \emph{complement} can be applied to languages.
\begin{itemize}
	\item \emph{Intersection}: $A \cap B = \{ x \mid x \in A \text{ and } x \in B \}$
	\item \emph{Union}: $A \cup B = \{ x \mid x \in A \text{ or } x \in B \}$
	\item \emph{Difference}: $A - B = \{ x \mid x \in A \text{ and } x \notin B \}$
\end{itemize}

Furthermore, we can also operate specifically over languages with the following operations:

\begin{itemize}
	\item \emph{Concatenation}: $L_1 \cdot L_2 = \{ xy \mid x \in L_1 \text{ and } y \in L_2 \}$
	\item \emph{Kleene Star}: $L^* = \bigcup_{n=0}^{\infty} L^n$, where $L^0 = \{\varepsilon\}$ and $L^n = L \cdot L^{n-1}$ for $n > 0$.
\end{itemize}


This operation combines every string

The \emph{complement} of a language $L$ over an alphabet $\Sigma$ is denoted by $\overline{L}$ and is defined as:
This

\section{Regular Languages}

\section{Regular Expressions}

\subsection{Derivatives}

\section{Automata}

\begin{tikzpicture}[shorten >=1pt,node distance=2cm,on grid,auto] 
   \node[state,initial] (q_0)   {$q_0$}; 
   \node[state] (q_1) [above right=of q_0] {$q_1$}; 
   \node[state] (q_2) [below right=of q_0] {$q_2$}; 
   \node[state,accepting](q_3) [below right=of q_1] {$q_3$};
    \path[->] 
    (q_0) edge  node {0} (q_1)
          edge  node [swap] {1} (q_2)
    (q_1) edge  node  {1} (q_3)
          edge [loop above] node {0} ()
    (q_2) edge  node [swap] {0} (q_3) 
          edge [loop below] node {1} ();
\end{tikzpicture}

\subsection{Finite Automata}

\subsection{Non-finite Automata}

\subsection{Position Automata}